"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5910],{540:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"Technical Docs/PoAI/AI Block Builder Algorithm","title":"AI Block Builder Algorithm","description":"Block builders are full blockchain nodes that store ready-made blocks of the blockchain and participate in forming and packaging new blocks. The block builder\'s basis is a Machine Learning (ML) model, which has the initial, specified parameters of the methodology for forming effective blocks from existing mempool transactions.","source":"@site/docs/Technical Docs/PoAI/AI Block Builder Algorithm.md","sourceDirName":"Technical Docs/PoAI","slug":"/Technical Docs/PoAI/AI Block Builder Algorithm","permalink":"/Technical Docs/PoAI/AI Block Builder Algorithm","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_label":"AI Block Builder Algorithm","sidebar_position":3},"sidebar":"docs","previous":{"title":"Taxonomy","permalink":"/Technical Docs/PoAI/Taxonomy"},"next":{"title":"Voting Algorithm","permalink":"/Technical Docs/PoAI/Voting Algorithm"}}');var n=i(4848),s=i(8453);const a={sidebar_label:"AI Block Builder Algorithm",sidebar_position:3},r="AI Block Builder Algorithm",c={},l=[];function h(e){const t={h1:"h1",header:"header",li:"li",ol:"ol",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"ai-block-builder-algorithm",children:"AI Block Builder Algorithm"})}),"\n",(0,n.jsx)(t.p,{children:"Block builders are full blockchain nodes that store ready-made blocks of the blockchain and participate in forming and packaging new blocks. The block builder's basis is a Machine Learning (ML) model, which has the initial, specified parameters of the methodology for forming effective blocks from existing mempool transactions."}),"\n",(0,n.jsx)(t.p,{children:"The model can also learn and improve the efficiency of its work in selecting transactions. The block builder considers transactions from the mempool for the block in the following priority (n - number of transactions in the block):"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"Highest price (>0.2n transactions)"}),"\n",(0,n.jsx)(t.li,{children:"Lowest price (>0.2n transactions) - to compensate highest prices"}),"\n",(0,n.jsx)(t.li,{children:"Average price (>0.5n)"}),"\n",(0,n.jsx)(t.li,{children:"Oldest transactions (>0.1n)"}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"One essential aspect of PoAI is making transactions optimised for affordability. This is why the block builder packs the blocks as much as possible and why the blockchain includes a halving algorithm that drives the reliance on transaction efficiency. Due to the dynamic nature of PoAI, the mechanism can sense and respond to attack vectors and attempts at manipulation and adjust accordingly to mitigate threats."}),"\n",(0,n.jsx)(t.p,{children:"Each block requires a certain volume of Points to be created (this is known as the PointPrice). The goal is to align the number of points for each block with the number of coins generated. For example, 1 point equals 0.001 coins. If the block requires a PointPrice of 10,000, the blockchain generates 10 new coins. When the blockchain reaches a certain amount of total PointPrice spent (for example, 30,000,000,000 points), each point becomes equal to 0.0005 coins. After reaching the second milestone (for example, 60,000,000,000), each point equals 0.00025 coins."}),"\n",(0,n.jsx)(t.p,{children:"An effective block is any block assembled so that the average PointPrice is close to the actual PointPrice. It includes transactions with the maximum useful information that can be entered into the block. For clarification, \u2018useful information\u02bc is PointData (the volume of Points). The goal is for the maximum amount of PointData to be included. A limited number of transactions with a higher-than-average PointPrice should reduce the number of users in the system who set a high PointPrice but still favor and compensate them with a limited number of transactions with a low PointPrice. Most of the average PointPrice transactions will be validated, incentivising users not to set high PointPrices."}),"\n",(0,n.jsx)(t.p,{children:"In contrast, other networks choose the highest gas fees, leading to a negative user experience. The alternative version provided by PoAI is illustrated below, where the vertical axis is the PointPrice, and the horizontal is the data length. The center of the target is the chosen price by the algorithm:"}),"\n",(0,n.jsx)("div",{children:(0,n.jsx)("img",{src:"/img/Screenshot 2024-05-01 at 9.01.05\u202fAM.png",alt:"PoAI PointPrice"})}),"\n",(0,n.jsx)(t.p,{children:"The effectiveness of the ML model depends on the server's technical resources and the frequency of block assembly. A block builder's ML model is trained based on its work in selecting transactions for a block, comparing its results with those of other block builders, and the final voting result, which determines whose block will be sent to the chain."}),"\n",(0,n.jsx)(t.p,{children:"\u200dThe more often a block builder forms a block, and the more mempool transactions it manages to sort through during the assembly of a new block, the more efficient the block is and the greater the chance that this particular block will be chosen for inclusion in the chain at the next stage. After the generation of the current block is completed and entered into the chain, a timer is started to assemble a new block. During the timer, all block builders are sorting through mempool transactions and selecting the best transactions to form a block. At the end of the timer, all block builders put their blocks forward to a voting process. The voting application includes the following information:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Block assembly"}),"\n",(0,n.jsx)(t.li,{children:"Block efficiency (% filling of the block with useful information)"}),"\n",(0,n.jsx)(t.li,{children:"Income of the block builder during its existence"}),"\n",(0,n.jsx)(t.li,{children:"Timestamp of the last block assembly"}),"\n",(0,n.jsx)(t.li,{children:"Percentage of votes out of the total number of attempts"}),"\n",(0,n.jsx)(t.li,{children:"Percentage of victory in voting out of the total number of people going to vote"}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"The below figure illustrates how PoAI selects which block builders can participate in the round:"}),"\n",(0,n.jsx)("div",{children:(0,n.jsx)("img",{src:"/img/Screenshot 2024-05-01 at 9.02.20\u202fAM.png",alt:"PoAI Block Builder Selection"})})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>a,x:()=>r});var o=i(6540);const n={},s=o.createContext(n);function a(e){const t=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);
//# sourceMappingURL=193c2be6.d108ee40.js.map