{"version":3,"file":"assets/js/193c2be6.d108ee40.js","mappings":"suCAEO,MAAMA,EAAc,CAC1BC,cAAe,6BACfC,iBAAkB,GAENC,EAAe,6BAEfC,EAAS,CAEtB,EAIaC,EAAM,GACnB,SAASC,EAAkBC,GACzB,MAAMC,EAAc,CAClBC,GAAI,KACJC,OAAQ,SACRC,GAAI,KACJC,GAAI,KACJC,EAAG,IACHC,GAAI,SACD,YACAP,EAAMQ,YAEX,OAAO,UAAM,WAAW,CACtBC,SAAU,EAAC,SAAKR,EAAYE,OAAQ,CAClCM,UAAU,SAAKR,EAAYC,GAAI,CAC7BQ,GAAI,6BACJD,SAAU,iCAEV,MAAM,SAAKR,EAAYK,EAAG,CAC5BG,SAAU,6UACR,MAAM,SAAKR,EAAYK,EAAG,CAC5BG,SAAU,4OACR,MAAM,UAAMR,EAAYI,GAAI,CAC9BI,SAAU,CAAC,MAAM,SAAKR,EAAYG,GAAI,CACpCK,SAAU,uCACR,MAAM,SAAKR,EAAYG,GAAI,CAC7BK,SAAU,qEACR,MAAM,SAAKR,EAAYG,GAAI,CAC7BK,SAAU,0BACR,MAAM,SAAKR,EAAYG,GAAI,CAC7BK,SAAU,gCACR,QACF,MAAM,SAAKR,EAAYK,EAAG,CAC5BG,SAAU,kaACR,MAAM,SAAKR,EAAYK,EAAG,CAC5BG,SAAU,0jBACR,MAAM,SAAKR,EAAYK,EAAG,CAC5BG,SAAU,0sBACR,MAAM,SAAKR,EAAYK,EAAG,CAC5BG,SAAU,oTACR,MAAM,SAAK,MAAO,CACpBA,UAAU,SAAK,MAAO,CACpBE,IAAK,oDACLC,IAAK,sBAEL,MAAM,SAAKX,EAAYK,EAAG,CAC5BG,SAAU,qWACR,MAAM,SAAKR,EAAYK,EAAG,CAC5BG,SAAU,msBACR,MAAM,UAAMR,EAAYM,GAAI,CAC9BE,SAAU,CAAC,MAAM,SAAKR,EAAYG,GAAI,CACpCK,SAAU,mBACR,MAAM,SAAKR,EAAYG,GAAI,CAC7BK,SAAU,sEACR,MAAM,SAAKR,EAAYG,GAAI,CAC7BK,SAAU,qDACR,MAAM,SAAKR,EAAYG,GAAI,CAC7BK,SAAU,yCACR,MAAM,SAAKR,EAAYG,GAAI,CAC7BK,SAAU,4DACR,MAAM,SAAKR,EAAYG,GAAI,CAC7BK,SAAU,oFACR,QACF,MAAM,SAAKR,EAAYK,EAAG,CAC5BG,SAAU,qGACR,MAAM,SAAK,MAAO,CACpBA,UAAU,SAAK,MAAO,CACpBE,IAAK,oDACLC,IAAK,qCAIb,CACe,SAASC,EAAWb,EAAQ,CAAC,GAC1C,MAAOc,QAASC,GAAa,KACxB,YACAf,EAAMQ,YAEX,OAAOO,GAAY,SAAKA,EAAW,IAC9Bf,EACHS,UAAU,SAAKV,EAAmB,IAC7BC,MAEFD,EAAkBC,EACzB,C,wDCxEA,MAAMgB,EAAkB,CAAC,EAEnBC,EAAa,gBAAoBD,GAUhC,SAASE,EAAiBV,GAC/B,MAAMW,EAAoB,aAAiBF,GAG3C,OAAO,UACL,WAEE,MAA0B,mBAAfT,EACFA,EAAWW,GAGb,IAAIA,KAAsBX,EACnC,EACA,CAACW,EAAmBX,GAExB,CAWO,SAASY,EAAYC,GAE1B,IAAIC,EAWJ,OAREA,EADED,EAAWE,qBAEsB,mBAA1BF,EAAWb,WACda,EAAWb,WAAWQ,GACtBK,EAAWb,YAAcQ,EAEfE,EAAiBG,EAAWb,YAGvC,gBACLS,EAAWO,SACX,CAACC,MAAOH,GACRD,EAAWZ,SAEf,C","sources":["webpack://docs/./docs/Technical Docs/PoAI/AI Block Builder Algorithm.md","webpack://docs/./node_modules/@mdx-js/react/lib/index.js"],"sourcesContent":["\n\nexport const frontMatter = {\n\tsidebar_label: 'AI Block Builder Algorithm',\n\tsidebar_position: 3\n};\nexport const contentTitle = 'AI Block Builder Algorithm';\nexport {default as metadata} from '@site/.docusaurus/docusaurus-plugin-content-docs/default/site-docs-technical-docs-po-ai-ai-block-builder-algorithm-md-193.json'\nexport const assets = {\n\n};\n\nimport {Fragment as _Fragment, jsx as _jsx, jsxs as _jsxs} from \"react/jsx-runtime\";\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nexport const toc = [];\nfunction _createMdxContent(props) {\n  const _components = {\n    h1: \"h1\",\n    header: \"header\",\n    li: \"li\",\n    ol: \"ol\",\n    p: \"p\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.header, {\n      children: _jsx(_components.h1, {\n        id: \"ai-block-builder-algorithm\",\n        children: \"AI Block Builder Algorithm\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Block builders are full blockchain nodes that store ready-made blocks of the blockchain and participate in forming and packaging new blocks. The block builder's basis is a Machine Learning (ML) model, which has the initial, specified parameters of the methodology for forming effective blocks from existing mempool transactions.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The model can also learn and improve the efficiency of its work in selecting transactions. The block builder considers transactions from the mempool for the block in the following priority (n - number of transactions in the block):\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Highest price (>0.2n transactions)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Lowest price (>0.2n transactions) - to compensate highest prices\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Average price (>0.5n)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Oldest transactions (>0.1n)\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"One essential aspect of PoAI is making transactions optimised for affordability. This is why the block builder packs the blocks as much as possible and why the blockchain includes a halving algorithm that drives the reliance on transaction efficiency. Due to the dynamic nature of PoAI, the mechanism can sense and respond to attack vectors and attempts at manipulation and adjust accordingly to mitigate threats.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Each block requires a certain volume of Points to be created (this is known as the PointPrice). The goal is to align the number of points for each block with the number of coins generated. For example, 1 point equals 0.001 coins. If the block requires a PointPrice of 10,000, the blockchain generates 10 new coins. When the blockchain reaches a certain amount of total PointPrice spent (for example, 30,000,000,000 points), each point becomes equal to 0.0005 coins. After reaching the second milestone (for example, 60,000,000,000), each point equals 0.00025 coins.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"An effective block is any block assembled so that the average PointPrice is close to the actual PointPrice. It includes transactions with the maximum useful information that can be entered into the block. For clarification, ‘useful informationʼ is PointData (the volume of Points). The goal is for the maximum amount of PointData to be included. A limited number of transactions with a higher-than-average PointPrice should reduce the number of users in the system who set a high PointPrice but still favor and compensate them with a limited number of transactions with a low PointPrice. Most of the average PointPrice transactions will be validated, incentivising users not to set high PointPrices.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In contrast, other networks choose the highest gas fees, leading to a negative user experience. The alternative version provided by PoAI is illustrated below, where the vertical axis is the PointPrice, and the horizontal is the data length. The center of the target is the chosen price by the algorithm:\"\n    }), \"\\n\", _jsx(\"div\", {\n      children: _jsx(\"img\", {\n        src: \"/img/Screenshot 2024-05-01 at 9.01.05 AM.png\",\n        alt: \"PoAI PointPrice\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The effectiveness of the ML model depends on the server's technical resources and the frequency of block assembly. A block builder's ML model is trained based on its work in selecting transactions for a block, comparing its results with those of other block builders, and the final voting result, which determines whose block will be sent to the chain.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"‍The more often a block builder forms a block, and the more mempool transactions it manages to sort through during the assembly of a new block, the more efficient the block is and the greater the chance that this particular block will be chosen for inclusion in the chain at the next stage. After the generation of the current block is completed and entered into the chain, a timer is started to assemble a new block. During the timer, all block builders are sorting through mempool transactions and selecting the best transactions to form a block. At the end of the timer, all block builders put their blocks forward to a voting process. The voting application includes the following information:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Block assembly\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Block efficiency (% filling of the block with useful information)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Income of the block builder during its existence\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Timestamp of the last block assembly\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Percentage of votes out of the total number of attempts\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Percentage of victory in voting out of the total number of people going to vote\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The below figure illustrates how PoAI selects which block builders can participate in the round:\"\n    }), \"\\n\", _jsx(\"div\", {\n      children: _jsx(\"img\", {\n        src: \"/img/Screenshot 2024-05-01 at 9.02.20 AM.png\",\n        alt: \"PoAI Block Builder Selection\"\n      })\n    })]\n  });\n}\nexport default function MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\n\n","/**\n * @import {MDXComponents} from 'mdx/types.js'\n * @import {Component, ReactElement, ReactNode} from 'react'\n */\n\n/**\n * @callback MergeComponents\n *   Custom merge function.\n * @param {Readonly<MDXComponents>} currentComponents\n *   Current components from the context.\n * @returns {MDXComponents}\n *   Additional components.\n *\n * @typedef Props\n *   Configuration for `MDXProvider`.\n * @property {ReactNode | null | undefined} [children]\n *   Children (optional).\n * @property {Readonly<MDXComponents> | MergeComponents | null | undefined} [components]\n *   Additional components to use or a function that creates them (optional).\n * @property {boolean | null | undefined} [disableParentContext=false]\n *   Turn off outer component context (default: `false`).\n */\n\nimport React from 'react'\n\n/** @type {Readonly<MDXComponents>} */\nconst emptyComponents = {}\n\nconst MDXContext = React.createContext(emptyComponents)\n\n/**\n * Get current components from the MDX Context.\n *\n * @param {Readonly<MDXComponents> | MergeComponents | null | undefined} [components]\n *   Additional components to use or a function that creates them (optional).\n * @returns {MDXComponents}\n *   Current components.\n */\nexport function useMDXComponents(components) {\n  const contextComponents = React.useContext(MDXContext)\n\n  // Memoize to avoid unnecessary top-level context changes\n  return React.useMemo(\n    function () {\n      // Custom merge via a function prop\n      if (typeof components === 'function') {\n        return components(contextComponents)\n      }\n\n      return {...contextComponents, ...components}\n    },\n    [contextComponents, components]\n  )\n}\n\n/**\n * Provider for MDX context.\n *\n * @param {Readonly<Props>} properties\n *   Properties.\n * @returns {ReactElement}\n *   Element.\n * @satisfies {Component}\n */\nexport function MDXProvider(properties) {\n  /** @type {Readonly<MDXComponents>} */\n  let allComponents\n\n  if (properties.disableParentContext) {\n    allComponents =\n      typeof properties.components === 'function'\n        ? properties.components(emptyComponents)\n        : properties.components || emptyComponents\n  } else {\n    allComponents = useMDXComponents(properties.components)\n  }\n\n  return React.createElement(\n    MDXContext.Provider,\n    {value: allComponents},\n    properties.children\n  )\n}\n"],"names":["frontMatter","sidebar_label","sidebar_position","contentTitle","assets","toc","_createMdxContent","props","_components","h1","header","li","ol","p","ul","components","children","id","src","alt","MDXContent","wrapper","MDXLayout","emptyComponents","MDXContext","useMDXComponents","contextComponents","MDXProvider","properties","allComponents","disableParentContext","Provider","value"],"sourceRoot":""}