{"version":3,"file":"assets/js/3ee9e72f.f5b86128.js","mappings":"+kCAEO,MAAMA,EAAc,CAC1BC,cAAe,yBACfC,iBAAkB,GAENC,EAAe,yBAEfC,EAAS,CAEtB,EAIaC,EAAM,GACnB,SAASC,EAAkBC,GACzB,MAAMC,EAAc,CAClBC,EAAG,IACHC,GAAI,KACJC,OAAQ,SACRC,GAAI,KACJC,EAAG,IACHC,GAAI,SACD,YACAP,EAAMQ,YAEX,OAAO,UAAM,WAAW,CACtBC,SAAU,EAAC,SAAKR,EAAYG,OAAQ,CAClCK,UAAU,SAAKR,EAAYE,GAAI,CAC7BO,GAAI,yBACJD,SAAU,6BAEV,MAAM,UAAMR,EAAYK,EAAG,CAC7BG,SAAU,CAAC,mGAAmG,SAAKR,EAAYC,EAAG,CAChIS,KAAM,0BACNF,SAAU,kBACR,6EACF,MAAM,UAAMR,EAAYM,GAAI,CAC9BE,SAAU,CAAC,MAAM,SAAKR,EAAYI,GAAI,CACpCI,SAAU,iNACR,MAAM,SAAKR,EAAYI,GAAI,CAC7BI,SAAU,+EACR,MAAM,SAAKR,EAAYI,GAAI,CAC7BI,SAAU,uXACR,MAAM,SAAKR,EAAYI,GAAI,CAC7BI,SAAU,ofACR,MAAM,SAAKR,EAAYI,GAAI,CAC7BI,SAAU,sLACR,MAAM,SAAKR,EAAYI,GAAI,CAC7BI,SAAU,6GACR,QACF,MAAM,SAAKR,EAAYK,EAAG,CAC5BG,SAAU,4LACR,MAAM,UAAMR,EAAYM,GAAI,CAC9BE,SAAU,CAAC,MAAM,SAAKR,EAAYI,GAAI,CACpCI,SAAU,yGACR,MAAM,SAAKR,EAAYI,GAAI,CAC7BI,SAAU,+FACR,QACF,MAAM,SAAKR,EAAYK,EAAG,CAC5BG,SAAU,yGACR,MAAM,SAAK,MAAO,CACpBA,UAAU,SAAK,MAAO,CACpBG,IAAK,oDACLC,IAAK,iCAIb,CACe,SAASC,EAAWd,EAAQ,CAAC,GAC1C,MAAOe,QAASC,GAAa,KACxB,YACAhB,EAAMQ,YAEX,OAAOQ,GAAY,SAAKA,EAAW,IAC9BhB,EACHS,UAAU,SAAKV,EAAmB,IAC7BC,MAEFD,EAAkBC,EACzB,C,wDCtDA,MAAMiB,EAAkB,CAAC,EAEnBC,EAAa,gBAAoBD,GAUhC,SAASE,EAAiBX,GAC/B,MAAMY,EAAoB,aAAiBF,GAG3C,OAAO,UACL,WAEE,MAA0B,mBAAfV,EACFA,EAAWY,GAGb,IAAIA,KAAsBZ,EACnC,EACA,CAACY,EAAmBZ,GAExB,CAWO,SAASa,EAAYC,GAE1B,IAAIC,EAWJ,OAREA,EADED,EAAWE,qBAEsB,mBAA1BF,EAAWd,WACdc,EAAWd,WAAWS,GACtBK,EAAWd,YAAcS,EAEfE,EAAiBG,EAAWd,YAGvC,gBACLU,EAAWO,SACX,CAACC,MAAOH,GACRD,EAAWb,SAEf,C","sources":["webpack://docs/./docs/Technical Docs/PoAI/AI-Validator Algorithm.md","webpack://docs/./node_modules/@mdx-js/react/lib/index.js"],"sourcesContent":["\n\nexport const frontMatter = {\n\tsidebar_label: 'AI-Validator Algorithm',\n\tsidebar_position: 5\n};\nexport const contentTitle = 'AI-Validator Algorithm';\nexport {default as metadata} from '@site/.docusaurus/docusaurus-plugin-content-docs/default/site-docs-technical-docs-po-ai-ai-validator-algorithm-md-3ee.json'\nexport const assets = {\n\n};\n\nimport {Fragment as _Fragment, jsx as _jsx, jsxs as _jsxs} from \"react/jsx-runtime\";\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nexport const toc = [];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    h1: \"h1\",\n    header: \"header\",\n    li: \"li\",\n    p: \"p\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.header, {\n      children: _jsx(_components.h1, {\n        id: \"ai-validator-algorithm\",\n        children: \"AI-Validator Algorithm\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"AI validators are lite blockchain nodes that store network wallet addresses and color markers. \", _jsx(_components.a, {\n        href: \"Color%20Marker%20System\",\n        children: \"Color markers\"\n      }), \" are a key part of validation and connecting a block to the blockchain:\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Each wallet in the system is classed as a HEX wallet as it has a colour attributed to it using a hexadecimal value. When a user signs a transaction in their crypto-wallet, a hexidecimal hash is generated.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"The AI validator stores information about the current color of the wallet.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"The block builder divides the transaction hash into six parts. It divides each part into two and adds them until it gets a number of one character. Thus, it receives six numbers in HEX, which the block builder glues into a single number, which we term a HEX transaction. Next, the block builder adds the HEX wallet with the HEX transaction and receives a new HEX wallet.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"The HEX of the new HEX wallet and the corresponding transaction hash are sent to the block for which AI validators are selected. AI validators are selected randomly among all those who voted for the AI builder in this round but only to those whose votes were not given to the winning AI builder (the random number is selected according to a special formula). AI validators also form the transaction hash into a transaction HEX and add it to the existing HEX wallet, obtaining a final HEX wallet.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"If the new HEX calculated by the AI validator coincides with the new HEX of the wallet transmitted in the block for all wallets, then the AI validator considers the block valid.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"The colors of the wallets change to those obtained by adding their current colors with HEX transactions.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Lite nodes can also send and receive transactions to power the blockchain wallet application. For a wallet address to become an AI validator, it must satisfy the following conditions:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"In the last N hours there have been transactions at the wallet address (I.E., the wallet is active);\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"the wallet address contains the N-amount of the native currency of the blockchain network.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The figure below illustrates how PoAI determines which validators are eligible to vote in the round:\"\n    }), \"\\n\", _jsx(\"div\", {\n      children: _jsx(\"img\", {\n        src: \"/img/Screenshot 2024-05-01 at 9.04.40â€¯AM.png\",\n        alt: \"PoAI Validator Selection\"\n      })\n    })]\n  });\n}\nexport default function MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\n\n","/**\n * @import {MDXComponents} from 'mdx/types.js'\n * @import {Component, ReactElement, ReactNode} from 'react'\n */\n\n/**\n * @callback MergeComponents\n *   Custom merge function.\n * @param {Readonly<MDXComponents>} currentComponents\n *   Current components from the context.\n * @returns {MDXComponents}\n *   Additional components.\n *\n * @typedef Props\n *   Configuration for `MDXProvider`.\n * @property {ReactNode | null | undefined} [children]\n *   Children (optional).\n * @property {Readonly<MDXComponents> | MergeComponents | null | undefined} [components]\n *   Additional components to use or a function that creates them (optional).\n * @property {boolean | null | undefined} [disableParentContext=false]\n *   Turn off outer component context (default: `false`).\n */\n\nimport React from 'react'\n\n/** @type {Readonly<MDXComponents>} */\nconst emptyComponents = {}\n\nconst MDXContext = React.createContext(emptyComponents)\n\n/**\n * Get current components from the MDX Context.\n *\n * @param {Readonly<MDXComponents> | MergeComponents | null | undefined} [components]\n *   Additional components to use or a function that creates them (optional).\n * @returns {MDXComponents}\n *   Current components.\n */\nexport function useMDXComponents(components) {\n  const contextComponents = React.useContext(MDXContext)\n\n  // Memoize to avoid unnecessary top-level context changes\n  return React.useMemo(\n    function () {\n      // Custom merge via a function prop\n      if (typeof components === 'function') {\n        return components(contextComponents)\n      }\n\n      return {...contextComponents, ...components}\n    },\n    [contextComponents, components]\n  )\n}\n\n/**\n * Provider for MDX context.\n *\n * @param {Readonly<Props>} properties\n *   Properties.\n * @returns {ReactElement}\n *   Element.\n * @satisfies {Component}\n */\nexport function MDXProvider(properties) {\n  /** @type {Readonly<MDXComponents>} */\n  let allComponents\n\n  if (properties.disableParentContext) {\n    allComponents =\n      typeof properties.components === 'function'\n        ? properties.components(emptyComponents)\n        : properties.components || emptyComponents\n  } else {\n    allComponents = useMDXComponents(properties.components)\n  }\n\n  return React.createElement(\n    MDXContext.Provider,\n    {value: allComponents},\n    properties.children\n  )\n}\n"],"names":["frontMatter","sidebar_label","sidebar_position","contentTitle","assets","toc","_createMdxContent","props","_components","a","h1","header","li","p","ul","components","children","id","href","src","alt","MDXContent","wrapper","MDXLayout","emptyComponents","MDXContext","useMDXComponents","contextComponents","MDXProvider","properties","allComponents","disableParentContext","Provider","value"],"sourceRoot":""}